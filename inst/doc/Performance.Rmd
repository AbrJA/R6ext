---
title: "Reference class performance tests"
output: html_document
---

<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Reference class performance tests}
-->

```{r}
library(microbenchmark)
library(pryr)
library(testclasses)
```
## Class definitions

Here are a number of ways of creating reference objects in R, starting with the most complicated (standard R reference classes) and ending with the simplest (an environment created by a closure).

### Standard R reference class

```{r}
A_rc <- setRefClass("A_rc", 
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <<- x,
    inc = function(n = 1) x <<- x + n
  )
)
```

### Winston's simple reference class

```{r}
B_wrc <- createRefClass("B_wrc",
  members = list(
    x = NULL,
    initialize = function(x = 1) self$x <<- x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Objects of this type also have an automatically-created `self` member:

```{r}
print(B_wrc$new())
```

### Environment created by a closure, with class attribute

```{r}
C_closure_class <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  structure(environment(), class = "D_closure")
}
```

This doesn't have a `self` member, although that could be added.

### Environment created by a closure, without class attribute

This is the simplest type of reference object:

```{r}
D_closure_noclass <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  environment()
}
```


## Memory footprint

How much memory does a single instance of each object take, and how much memory does each additional object take?

```{r}
# Utility functions for calculating sizes
obj_size <- function(newfun) {
  data.frame(
    one = as.numeric(object_size(newfun())),
    incremental = as.numeric(object_size(newfun(), newfun()) - object_size(newfun()))
  )
}

obj_sizes <- function(...) {
  dots <- list(...)
  sizes <- Map(obj_size, dots)
  do.call(rbind, sizes)
}
```

Sizes of each type of object, in bytes:

```{r}
obj_sizes(
  A_rc = A_rc$new,
  B_wrc = B_wrc$new,
  C_closure_class = C_closure_class,
  D_closure_noclass = D_closure_noclass
)
```


## Object instantiation speed

How much time does it take to create one of these objects?

```{r}
# Garbage collect now so that we (probably) won't do it in the middle of a run
invisible(gc())
speed <- microbenchmark(
  A_rc = A_rc$new(),
  B_wrc = B_wrc$new(),
  C_closure_class = C_closure_class(),
  D_closure_noclass = D_closure_noclass(),
  unit = "ns"
)
speed
```

Standard R reference classes are much slower to instantiate than the other types of classes, with a median of `r median(speed[speed$expr == "A_rc", "time"]) / 1e6` milliseconds per instantiation.

C is slower than D, though I'm not sure why. The only difference is that the returned object has a class attribute, and R shouldn't have to do any S3 method lookup, since the object returned by the instantiation function is simply discarded.


## Method call speed

How much overhead is there when calling a method from one of these objects?

```{r}
A <- A_rc$new()
B <- B_wrc$new()
C <- C_closure_class()
D <- D_closure_noclass()

invisible(gc())
microbenchmark(
  A_rc = A$inc(),
  B_wrc = B$inc(),
  C_closure_class = C$inc(),
  D_closure_noclass = D$inc(),
  unit = "ns"
)
```


As expected, standard reference classes are the slowest by a large margin. The difference between C and D is probably due to S3 method lookup for the `$` function -- there could be a `$.myclass` method which would be called for `myclass` objects.

When we manually remove the class from the B object, it performs on par with D.

```{r}
# Really create a reference object without a class
B2 <- B_wrc$new()
class(B2) <- NULL
microbenchmark(
  B_wrc_noclass = B2$inc(),
  D_closure_noclass = D$inc(),
  unit = "ns"
)
```


## Overhead from using `self`

With standard reference class objects, you can modify fields using the `<<-` operator, or by using the `self` object. For example, compare the `inc()` methods of these two classes:

```{r}
rc_no_self <- setRefClass("rc_no_self", 
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <<- x,
    inc = function(n = 1) x <<- x + n
  )
)

rc_self <- setRefClass("rc_self", 
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <<- x,
    inc = function(n = 1) .self$x <- x + n
  )
)
```

Winston's reference classes are similar, except they use `self` instead of `.self`:

```{r}
wrc_no_self <- createRefClass("wrc_no_self",
  members = list(
    x = 1,
    inc = function(n = 1) x <<- x + n
  )
)

wrc_self <- createRefClass("wrc_self",
  members = list(
    x = 1,
    inc = function(n = 1) self$x <- self$x + n
  )
)
```


```{r}
rc_no_self_obj <- rc_no_self$new()
rc_self_obj <- rc_self$new()
wrc_no_self_obj <- wrc_no_self$new()
wrc_self_obj <- wrc_self$new()

invisible(gc())
microbenchmark(
  rc_no_self = rc_no_self_obj$inc(),
  rc_self = rc_self_obj$inc(),
  wrc_no_self = wrc_no_self_obj$inc(),
  wrc_self = wrc_self_obj$inc(),
  unit = "ns"
)
```

Using `.self` or `self` adds some overhead, which makes sense when you consider how R searches for objects.

When the method accesses `x` without using `.self`, R first searches in the execution environment but doesn't find `x` there, so it then searches in the parent environment, finds `x` there, and assigns the value.

When using `.self`, R searches for `.self` in the function's execution environment but doesn't find it there, so it looks in the parent environment (which also happens to be the object environment, as well as the environment that `.self` points to) and does find it there. Then it looks in the `.self` environment for `x`, and assigns the value.

## Lists vs. environments, and S3 object access overhead

This compares member access time with lists vs. environments, and when the list/environment has a class attribute vs. not having a class. If the class has a class attribute, R will use method lookup for `$`, which adds overhead.

```{r}
list_noclass <- list(x = 10)
list_class <- structure(list(x = 10), class = "foo")
env_noclass <- new.env()
env_noclass$x <- 10
env_class <- structure(new.env(), class = "foo")
env_class$x <- 10

invisible(gc())
microbenchmark(
  list_noclass = list_noclass,
  list_class = list_class$x,
  env_noclass = env_noclass,
  env_class = env_class$x
)
```
