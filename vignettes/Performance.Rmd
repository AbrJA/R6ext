---
title: "R6 and Reference class performance tests"
output:
  html_document:
    theme: null
    css: mystyle.css
    toc: yes
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Reference and R6 class performance tests}
-->

```{r echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.width = 3.9, fig.height = 3.5)
library(microbenchmark)
# Only print 3 significant digits
print_microbenchmark <- function (x, unit, order = NULL, ...) {
  s <- summary(x, unit = unit)
  cat("Unit: ", attr(s, "unit"), "\n", sep = "")

  timing_cols <- c("min", "lq", "median", "uq", "max")
  s[timing_cols] <- lapply(s[timing_cols], signif, digits = 3)
  s[timing_cols] <- lapply(s[timing_cols], format, big.mark = ",")

  print(s, ..., row.names = FALSE)
}
assignInNamespace("print.microbenchmark", print_microbenchmark,
  "microbenchmark")
```

This document compares the memory costs and speed of R's reference classes against R6 classes and simple environments. For must uses, R6 and reference classes have comparable features, but as we'll see, R6 classes are faster and lighter weight.

*****

First we'll load some packages which will be used below:

```{r}
library(microbenchmark)
options(microbenchmark.unit = "us")
library(pryr)  # For object_size function
library(R6)
```


```{r echo=FALSE}
library(ggplot2)
library(scales)

# Set up ggplot2 theme
my_theme <- theme_bw(base_size = 10) +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank()
    )
```

*****

Class definitions
=================

We'll start by defining a number of classes or class-like entities, using reference classes, R6 classes, and simple environments that are created directly by functions. These classes will be used for the speed and memory tests that follow.

All of these classes have the same basic characteristics:

* A field named `x` that contains a number.
* An way of initializing the value of `x`.
* A method named `getx` for retrieving the value of `x`.
* A method named `inc` for incrementing the value of `x`.

The fields and methods are accessed with the `$` operator, so if we have an object named `obj`, we could use `obj$x` or `obj$getx()`.

## R reference class

```{r}
A_rc <- setRefClass("A_rc", 
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

In reference classes, the binding that points back to the object is named `.self`. Within a method, assignment can be done by using `.self`, as in `.self$x <- 10`, or by using `<<-`, as in `x <<- 10`.

To create an object, simply call `$new()` on the class:

```{r}
A_rc$new()
```

## R6 class

Creating an R6 class is similar to the reference class, except that there's no need to separate the fields and methods, and you can't specify the types of the fields.

```{r}
B_r6 <- R6Class("B_r6",
  public = list(
    x = NULL,
    initialize = function(x = 1) self$x <- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Whereas reference classes use `.self`, R6 classes use `self` (without the leading period). As with reference classes, objects are instantiated by calling `$new()`:

```{r}
B_r6$new()
```

An R6 object essentially just an environment. The methods for an R6 object have bindings (that is, they have names) in that environment, and also have that environment as their enclosing environment (the "run in" that environment).

## R6 class, without class attribute

By default, a class attribute is added to R6 objects. This attribute adds a slight performance penalty because R will attempt to use S3 dispatch when using `$` on the object.

It's possible generate objects without the class attribute, by using `class=FALSE`:

```{r}
C_r6_noclass <- R6Class("C_r6_noclass",
  public = list(
    x = NULL,
    initialize = function(x = 1) self$x <- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  ),
  class = FALSE
)
```

Note that without the class attribute, S3 method dispatch on the objects is not possible.

## R6 class, with public and private members

This is a variant of the previous type of reference class, but this version has public and private members.

```{r}
D_r6_priv <- R6Class("D_r6_priv",
  private = list(x = NULL),
  public = list(
    initialize = function(x = 1) private$x <- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Instead of a single `self` object which refers to all items in an object, these objects have `self` (which refers to the public items) and `private`.

```{r}
D_r6_priv$new()
```


## Environment created by a closure, with class attribute

In R, environments are passed by reference. A simple way to create an object that's passed by reference is to use the environment created by the invocation of a function. The function below captures that environment, attaches a class to it, and returns it:

```{r}
E_closure_class <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  getx <- function() x
  self <- environment()
  class(self) <- "E_closure"
  self
}
```

Even though `x` isn't declared in the function body, it gets captured because it's an argument to the function.

```{r}
ls(E_closure_class())
```

Objects created this way are very similar to those created by `B_r6`. The main difference is that those created by `B_r6` contain an `initialize` function:


## Environment created by a closure, without class attribute

We can make an even simpler type of reference object to the previous one, by not having a a class attribute, and not having `self` object:

```{r}
F_closure_noclass <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  getx <- function() x
  environment()
}
```

This is simply an environment with some objects in it.

*****

Tests
=====

For all the timings using `microbenchmark()`, the results are reported in microseconds, and the most useful value is probably the median column.

## Memory footprint

```{r echo = FALSE}
# Utility functions for calculating sizes
obj_size <- function(expr, .env = parent.frame()) {
  size_n <- function(n = 1) {
    objs <- lapply(1:n, function(x) eval(expr, .env))
    as.numeric(do.call(object_size, objs))
  }

  data.frame(one = size_n(1), incremental = size_n(2) - size_n(1))
}

obj_sizes <- function(..., .env = parent.frame()) {
  exprs <- as.list(match.call(expand.dots = FALSE)$...)
  names(exprs) <- lapply(1:length(exprs),
    FUN = function(n) {
      name <- names(exprs)[n]
      if (is.null(name) || name == "") paste(deparse(exprs[[n]]), collapse = " ")
      else name
    })

  sizes <- mapply(obj_size, exprs, MoreArgs = list(.env = .env), SIMPLIFY = FALSE)
  do.call(rbind, sizes)
}
```


How much memory does a single instance of each object take, and how much memory does each additional object take? We'll use the functions `obj_size` and `obj_sizes` (shown at the bottom of this document) to calculate the sizes.

Sizes of each type of object, in bytes:

```{r}
sizes <- obj_sizes(
  A_rc$new(),
  B_r6$new(),
  C_r6_noclass$new(),
  D_r6_priv$new(),
  E_closure_class(),
  F_closure_noclass()
)
sizes
```

The results are plotted below. Note that the plots have very different x scales.

```{r echo = FALSE, results = 'hold'}
sizes$name <- factor(c("A_rc", "B_r6", "C_r6_noclass", "D_r6_priv", "E_closure_class",
                       "F_closure_noclass"))
sizes$name <- factor(sizes$name, rev(levels(sizes$name)))

ggplot(sizes, aes(y = name, x = one)) +
  geom_segment(aes(yend = name), xend = 0, colour = "gray80") +
  geom_point(size = 2) +
  scale_x_continuous(limits = c(0, max(sizes$one[-1]) * 1.5),
                     expand = c(0, 0), oob = rescale_none) +
  scale_y_discrete(
    breaks = sizes$name,
    labels = c("A_rc (off chart)", "B_r6", "C_r6_noclass", "D_r6_priv",
               "E_closure_class", "F_closure_noclass")) +
  my_theme +
  ggtitle("First object")

ggplot(sizes, aes(y = reorder(name, incremental), x = incremental)) +
  geom_segment(aes(yend = name), xend = 0, colour = "gray80") +
  scale_x_continuous(limits = c(0, max(sizes$incremental) * 1.05),
                     expand = c(0, 0)) +
  geom_point(size = 2) +
  my_theme +
  ggtitle("Additional objects")
```


It looks like using a reference class takes up a huge amount of memory, but much of that is shared between reference classes. Adding an object from a different reference class doesn't require much more memory --- around 38KB:

```{r}
A_rc2 <- setRefClass("A_rc2",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 2) .self$x <<- x,
    inc = function(n = 2) x <<- x * n
  )
)

# Calcualte the size of a new A_rc2 object, over and above an A_rc object
as.numeric(object_size(A_rc$new(), A_rc2$new()) - object_size(A_rc$new()))
```

## Object instantiation speed

How much time does it take to create one of these objects? This shows the median time, in microseconds:

```{r}
# Function to extract the medians from microbenchmark results
mb_summary <- function(x) {
  res <- summary(x, unit="us")
  data.frame(name = res$expr, median = res$median)
}

speed <- microbenchmark(
  A_rc = A_rc$new(),
  B_r6 = B_r6$new(),
  C_r6_noclass = C_r6_noclass$new(),
  D_r6_priv = D_r6_priv$new(),
  E_closure_class = E_closure_class(),
  F_closure_noclass = F_closure_noclass()
)
speed <- mb_summary(speed)
speed
```

The first plot below shows the median instantiation time. The second plot is the same data, but rescaled so that the non-reference class bars can be more easily compared.

```{r echo = FALSE, results = 'hold', fig.width = 8}
speed$name <- factor(speed$name, rev(levels(speed$name)))

p <- ggplot(speed, aes(y = name, x = median)) +
  geom_segment(aes(yend = name), xend = 0, colour = "gray80") +
  geom_point(size = 2) +
  scale_x_continuous(limits = c(0, max(speed$median) * 1.05), expand = c(0, 0)) +
  my_theme +
  ggtitle("Median time to instantiate object (µs)")

p
```

R reference classes are much slower to instantiate than the other types of classes. Instantiating R6 objects is roughly 10 times faster. Creating an environment with a closure is another 10-20 times faster still.


## Field access speed

How much time does it take to access a field in an object? First we'll make some objects:

```{r}
A <- A_rc$new()
B <- B_r6$new()
C <- C_r6_noclass$new()
D <- D_r6_priv$new()
E <- E_closure_class()
F <- F_closure_noclass()
```

And then get a value from these objects:

```{r}
speed <- microbenchmark(
  A_rc = A$x,
  B_r6 = B$x,
  C_r6_noclass = C$x,
  D_r6_priv = D$private$x,
  E_closure_class = E$x,
  F_closure_noclass = F$x
)
speed <- mb_summary(speed)
speed
```


```{r echo = FALSE, results = 'hold', fig.width = 8}
speed$name <- factor(speed$name, rev(levels(speed$name)))

p <- ggplot(speed, aes(y = name, x = median)) +
  geom_segment(aes(yend = name), xend = 0, colour = "gray80") +
  geom_point(size = 2) +
  scale_x_continuous(limits = c(0, max(speed$median) * 1.05), expand = c(0, 0)) +
  my_theme +
  ggtitle("Median time to access field (µs)")

p
```

Accessing the field of a reference class is much slower than the other methods. Accessing a field from the two objects that don't have a class attribute, `C_r6_noclass`, and `F_closure_noclass`, is much faster than the others. This is because, for the objects that have a class attribute, R attempts to look up an S3 method for `$`.


## Field setting speed

How much time does it take to set the value of a field in an object?

```{r}
speed <- microbenchmark(
  A_rc = A$x <- 4,
  B_r6 = B$x <- 4,
  C_r6_noclass = C$x <- 4,
  D_r6_priv = D$private$x <- 4,
  E_closure_class = E$x <- 4,
  F_closure_noclass = F$x <- 4
)
speed <- mb_summary(speed)
speed
```

```{r echo = FALSE, results = 'hold', fig.width = 8}
speed$name <- factor(speed$name, rev(levels(speed$name)))

p <- ggplot(speed, aes(y = name, x = median)) +
  geom_segment(aes(yend = name), xend = 0, colour = "gray80") +
  geom_point(size = 2) +
  scale_x_continuous(limits = c(0, max(speed$median) * 1.05), expand = c(0, 0)) +
  my_theme +
  ggtitle("Median time to set field (µs)")

p
```

Reference classes are significantly slower than the others, again. In this case, there's additional overhead due to type-checking the value.

Once again, the no-class objects are significantly faster than the others, again probably due to attempted S3 dispatch on the `` `$<-` `` function.

Assignment to the private `x` field of the `D_r6_priv` object takes about twice as long as assignment in the `B_R6` object. This is probably it calls the `$` function on an object with a class and then the  `` `$<-` `` function on an object without a class. The total time is a little surprising though, since it's larger than the sum of those times for other objects.

## Method call speed

How much overhead is there when calling a method from one of these objects? All of these `getx()` methods simply return the value of `x` in the object.

```{r}
speed <- microbenchmark(
  A_rc = A$getx(),
  B_r6 = B$getx(),
  C_r6_noclass = C$getx(),
  D_r6_priv = D$getx(),
  E_closure_class = E$getx(),
  F_closure_noclass = F$getx()
)
speed <- mb_summary(speed)
speed
```

```{r echo = FALSE, results = 'hold', fig.width = 8}
speed$name <- factor(speed$name, rev(levels(speed$name)))

p <- ggplot(speed, aes(y = name, x = median)) +
  geom_segment(aes(yend = name), xend = 0, colour = "gray80") +
  geom_point(size = 2) +
  my_theme +
  ggtitle("Median time to call a method that accesses a field (µs)")

p
```

Overall, method call speed is very close to the field access speed.


## Assignment using `.self$x <-` vs. `x <<-`

With reference class objects, you can modify fields using the `<<-` operator, or by using the `.self` object. For example, compare the `setx()` methods of these two classes:

```{r}
rc_self <- setRefClass("rc_self",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function() .self$x <- 1,
    setx = function(n = 2) .self$x <- n
  )
)

rc_noself <- setRefClass("rc_noself",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function() x <<- 1,
    setx = function(n = 2) x <<- n
  )
)
```

R6 classes are similar, except they use `self` instead of `.self`:

```{r}
r6_self <- R6Class("r6_self",
  public = list(
    x = 1,
    setx = function(n = 2) self$x <- n
  )
)

r6_noself <- R6Class("r6_noself",
  public = list(
    x = 1,
    setx = function(n = 2) x <<- n
  )
)
```


```{r}
rc_self_obj <- rc_self$new()
rc_noself_obj <- rc_noself$new()
r6_self_obj <- r6_self$new()
r6_noself_obj <- r6_noself$new()

speed <- microbenchmark(
  rc_self = rc_self_obj$setx(),
  rc_noself = rc_noself_obj$setx(),
  r6_self = r6_self_obj$setx(),
  r6_noself = r6_noself_obj$setx()
)
speed <- mb_summary(speed)
speed
```

```{r echo = FALSE, results = 'hold', fig.width = 8}
speed$name <- factor(speed$name, rev(levels(speed$name)))

p <- ggplot(speed, aes(y = name, x = median)) +
  geom_segment(aes(yend = name), xend = 0, colour = "gray80") +
  geom_point(size = 2) +
  my_theme +
  ggtitle("Assignment to a field using self vs <<- (µs)")

p
```

For reference and R6 classes, assignment using `.self$x <-` is somewhat slower than using `x <<-`.

## Overhead from using `$` on objects with a class attribute

There is some overhead when using `$` on an object that has a class attribute. In the test below, we'll create three different kinds of objects:

1. An environment with no class attribute.
1. An environment with a class `"e2"`, but without a `$.e2` S3 method.
1. An environment with a class `"e3"`, which has a `$.e3` S3 method that simply returns `NULL`.

Each one of these environments will contain an object `x`.

```{r}
e1 <- new.env(hash = FALSE, parent = emptyenv())
e2 <- new.env(hash = FALSE, parent = emptyenv())
e3 <- new.env(hash = FALSE, parent = emptyenv())

e1$x <- 1
e2$x <- 1
e3$x <- 1

class(e2) <- "e2"
class(e3) <- "e3"

# Define an S3 method for class e3
`$.e3` <- function(x, name) {
  NULL
}
```

Now we can run timing tests for calling `$` on each type of object. Note that for the `e3` object, the `$` function does nothing --- it simply returns `NULL`.

```{r}
speed <- microbenchmark(
  e1$x,
  e2$x,
  e3$x
)
speed <- mb_summary(speed)
speed
```

Using `$` on `e2` and `e3` is much slower than on `e1`. This is because `e2` and `e3` have a class attribute. Even though there's no `$` method defined for `e2`, doing `e2$x` still about 6 times slower than `e1$x`, simply because R looks for an appropriate S3 method.

`e3$x` is slightly faster than `e2$x`; this is probably because the `$.e3` function doesn't actually do anything other than return NULL.

If an object has a class attribute, R will attempt to look for a method every time `$` is called. This can slow things down considerably, if `$` is used often.

## Lists vs. environments, and `$` vs. `[[`

Lists could also be used for creating classes. How much time does it take to access items using `$` for lists vs. environments? We'll also compare using `obj$x` to `obj[['x']]`.

```{r}
lst <- list(x = 10)
env <- new.env()
env$x <- 10

mb_summary(microbenchmark(
  lst = lst$x,
  env = env$x,
  lst[['x']],
  env[['x']]
))
```

Performance is comparable across environments and lists.

The `[[` operator is slightly faster than `$`, probably because it doesn't need to convert the unevaluated symbol to a string.

*****

Wrap-up
=======

R6 objects take less memory and are significantly faster than R's reference class objects. Reference classes do provide additional features, such as type checking of fields, but they also have other drawbacks --- notably, they are built using S4 classes and so they bring with them issues with using S4.

Another major advantage of R6 objects is that they are much simpler than R's reference class objects: R6 objects are essentially just environments.

*****

Appendix
========

## Functions for calculating object sizes

```{r eval=FALSE}
# Utility functions for calculating sizes
obj_size <- function(expr, .env = parent.frame()) {
  size_n <- function(n = 1) {
    objs <- lapply(1:n, function(x) eval(expr, .env))
    as.numeric(do.call(object_size, objs))
  }

  data.frame(one = size_n(1), incremental = size_n(2) - size_n(1))
}

obj_sizes <- function(..., .env = parent.frame()) {
  exprs <- as.list(match.call(expand.dots = FALSE)$...)
  names(exprs) <- lapply(1:length(exprs),
    FUN = function(n) {
      name <- names(exprs)[n]
      if (is.null(name) || name == "") paste(deparse(exprs[[n]]), collapse = " ")
      else name
    })

  sizes <- mapply(obj_size, exprs, MoreArgs = list(.env = .env), SIMPLIFY = FALSE)
  do.call(rbind, sizes)
}
```


## System information

```{r}
sessionInfo()
```
