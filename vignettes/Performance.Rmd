---
title: "Reference and R6 class performance tests"
output:
  html_document:
    theme: null
    css: mystyle.css
    toc: yes
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Reference and R6 class performance tests}
-->

```{r echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(microbenchmark)
# Only print 3 significant digits
print_microbenchmark <- function (x, unit, order = NULL, ...) {
  s <- summary(x, unit = unit)
  cat("Unit: ", attr(s, "unit"), "\n", sep = "")

  timing_cols <- c("min", "lq", "median", "uq", "max")
  s[timing_cols] <- lapply(s[timing_cols], signif, digits = 3)
  s[timing_cols] <- lapply(s[timing_cols], format, big.mark = ",")

  print(s, ..., row.names = FALSE)
}
assignInNamespace("print.microbenchmark", print_microbenchmark,
  "microbenchmark")
```

Reference classes in R are very useful for some situations, but they don't come for free. In this document, I'll explore the costs in memory and speed of standard R reference classes vs. other reference objects which are created in different ways.

```{r}
library(microbenchmark)
options(microbenchmark.unit = "us")
library(pryr)  # For object_size function
library(R6)
```

*****

Class definitions
=================

Here are a number of ways of creating reference objects in R, starting with the most complicated (standard R reference class) and ending with the simplest (an environment created by a closure).

## R reference class

```{r}
A_rc <- setRefClass("A_rc", 
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

## R6 class

R6 classes are similar to R's standard reference objects, but they are simpler.

```{r}
B_r6 <- createR6Class("B_r6",
  public = list(
    x = NULL,
    initialize = function(x = 1) self$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Objects of this type also have an automatically-created `self` member:

```{r}
print(B_r6$new())
```

## R6 class, without class attribute

By default, a class attribute is added to the objects generated by the simple reference classes. This attribute adds a slight performance penalty because R will use S3 dispatch when using `$` on the object.

It's possible generate objects without the class attribute, by using `class=FALSE`:

```{r}
C_r6_noclass <- createR6Class("C_r6_noclass",
  public = list(
    x = NULL,
    initialize = function(x = 1) self$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  ),
  class = FALSE
)
```

## R6 class, with public and private members

This is a variant of the previous type of reference class, but this version has public and private members.

```{r}
D_r6_priv <- createR6Class("D_r6_priv",
  private = list(x = NULL),
  public = list(
    initialize = function(x = 1) private$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Instead of a single `self` object which refers to all items in an object, these objects have `self` (which refers to the public items) and `private`.

```{r}
print(D_r6_priv$new())
```

## Environment created by a closure, with class attribute

This is simply an environment with a class attached to it.

```{r}
E_closure_class <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  getx <- function() x
  self <- environment()
  class(self) <- "D_closure"
  self
}
```

Even though `x` isn't declared in the function body, it gets captured because it's an argument to the function.

```{r}
# Roundabout way to print the contents of a E object
str(as.list.environment(E_closure_class()))
```

Objects created this way are very similar to those created by `B_r6`. The main difference is that those created by `B_r6` contain an `initialize` function:

```{r}
str(as.list.environment(B_r6$new()))
```


## Environment created by a closure, without class attribute

This is the simplest type of reference object:

```{r}
F_closure_noclass <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  getx <- function() x
  environment()
}
```

There are two differences between E and F: objects of type F don't have a class attribute, and they don't have a `self` object.

*****

Tests
=====

For all the timings using `microbenchmark()`, the results are reported in microseconds, and the most useful value is probably the median column.

## Memory footprint

How much memory does a single instance of each object take, and how much memory does each additional object take?

```{r}
# Utility functions for calculating sizes
obj_size <- function(expr, .env = parent.frame()) {
  size_n <- function(n = 1) {
    objs <- lapply(1:n, function(x) eval(expr, .env))
    as.numeric(do.call(object_size, objs))
  }

  data.frame(one = size_n(1), incremental = size_n(2) - size_n(1))
}

obj_sizes <- function(..., .env = parent.frame()) {
  exprs <- as.list(match.call(expand.dots = FALSE)$...)
  names(exprs) <- lapply(1:length(exprs),
    FUN = function(n) {
      name <- names(exprs)[n]
      if (is.null(name) || name == "") paste(deparse(exprs[[n]]), collapse = " ")
      else name
    })

  sizes <- mapply(obj_size, exprs, MoreArgs = list(.env = .env), SIMPLIFY = FALSE)
  do.call(rbind, sizes)
}

```

Sizes of each type of object, in bytes:

```{r}
obj_sizes(
  A_rc$new(),
  B_r6$new(),
  C_r6_noclass$new(),
  D_r6_priv$new(),
  E_closure_class(),
  F_closure_noclass()
)
```


It looks like using a reference class takes up a huge amount of memory, but much of that is shared between reference classes. Adding another object from a different reference class doesn't require much more memory -- around 38KB:

```{r}
A_rc2 <- setRefClass("A_rc2",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 2) .self$x <<- x,
    inc = function(n = 2) x <<- x * n
  )
)

# Size of a new A_rc2 object, over and above an A_rc object
as.numeric(object_size(A_rc$new(), A_rc2$new()) - object_size(A_rc$new()))
```

## Object instantiation speed

How much time does it take to create one of these objects?

```{r}
speed <- microbenchmark(
  A_rc$new(),
  B_r6$new(),
  C_r6_noclass$new(),
  D_r6_priv$new(),
  E_closure_class(),
  F_closure_noclass()
)
speed
```

R reference classes are much slower to instantiate than the other types of classes, with a median of `r median(speed[speed$expr == "A_rc$new()", "time"]) / 1e6` milliseconds per instantiation.


## Field access speed

How much time does it take to access a field in an object? First we'll make some objects:

```{r}
A <- A_rc$new()
B <- B_r6$new()
C <- C_r6_noclass$new()
D <- D_r6_priv$new()
E <- E_closure_class()
F <- F_closure_noclass()
```

Getting a value:

```{r}
microbenchmark(
  A_rc = A$x,
  B_r6 = B$x,
  C_r6_noclass = C$x,
  D_r6_priv = D$private$x,
  E_closure_class = E$x,
  F_closure_noclass = F$x
)
```


Setting a value:

```{r}
microbenchmark(
  A_rc = A$x <- 4,
  B_r6 = B$x <- 4,
  C_r6_noclass = C$x <- 4,
  D_r6_priv = D$private$x <- 4,
  E_closure_class = E$x <- 4,
  F_closure_noclass = F$x <- 4
)
```

The differences between the pairs C, D, and E, F are due to overhead from the class attribute. Because C and E have a class attribute, R will check whether there is a `$` method for its class. All of the objects A, B, D, and E have a class, while C and F do not.

The standard reference class is slowest.


## Method call speed

How much overhead is there when calling a method from one of these objects?

```{r}
microbenchmark(
  A_rc = A$getx(),
  B_r6 = B$getx(),
  C_r6_noclass = C$getx(),
  D_r6_priv = D$getx(),
  E_closure_class = E$getx(),
  F_closure_noclass = F$getx()
)
```

As expected, method call speed is very close to the field access speed -- in this case there's just the small additional overhead of calling a function.

Standard reference classes are the slowest by a large margin.

The difference between the pairs B, C, and E, F is probably due to S3 method lookup for the `$` function -- there could be a `$.myclass` method which would be called for `myclass` objects.


## Overhead from using `self`

With standard reference class objects, you can modify fields using the `<<-` operator, or by using the `self` object. For example, compare the `inc()` methods of these two classes:

```{r}
rc_self <- setRefClass("rc_self",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <- x,
    inc = function(n = 1) .self$x <- x + n
  )
)

rc_no_self <- setRefClass("rc_no_self",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <- x,
    inc = function(n = 1) x <<- x + n
  )
)
```

R6 classes are similar, except they use `self` instead of `.self`:

```{r}
r6_self <- createR6Class("r6_self",
  public = list(
    x = 1,
    inc = function(n = 1) self$x <- x + n
  )
)

r6_no_self <- createR6Class("r6_no_self",
  public = list(
    x = 1,
    inc = function(n = 1) x <<- x + n
  )
)
```


```{r}
rc_self_obj <- rc_self$new()
rc_no_self_obj <- rc_no_self$new()
r6_self_obj <- r6_self$new()
r6_no_self_obj <- r6_no_self$new()

microbenchmark(
  rc_self = rc_self_obj$inc(),
  rc_no_self = rc_no_self_obj$inc(),
  r6_self = r6_self_obj$inc(),
  r6_no_self = r6_no_self_obj$inc()
)
```

Using `.self` or `self` adds some overhead, which makes sense when you consider how R searches for objects.

When the method accesses `x` without using `.self`, R first searches in the execution environment but doesn't find `x` there, so it then searches in the parent environment, finds `x` there, and assigns the value.

When using `.self`, R searches for `.self` in the function's execution environment but doesn't find it there, so it looks in the parent environment (which also happens to be the object environment, as well as the environment that `.self` points to) and does find it there. Then it looks in the `.self` environment for `x`, and assigns the value.

Additionally, there is some overhead when the environment has a class attribute.

```{r}
r6_self_obj <- r6_self$new()
r6_no_self_obj <- r6_no_self$new()

r6_self_noclass_obj <- r6_self$new()
class(r6_self_noclass_obj) <- NULL
r6_no_self_noclass_obj <- r6_no_self$new()
class(r6_no_self_noclass_obj) <- NULL

microbenchmark(
  r6_self = r6_self_obj$inc(),
  r6_no_self = r6_no_self_obj$inc(),
  r6_self_noclass = r6_self_noclass_obj$inc(),
  r6_no_self_noclass = r6_no_self_noclass_obj$inc()
)
```


## Lists vs. environments, and S3 object access overhead

This compares member access time with lists vs. environments, and when the list/environment has a class attribute vs. not having a class. If the class has a class attribute, R will use method lookup for `$`, which adds overhead.

```{r}
list_noclass <- list(x = 10)
list_class <- structure(list(x = 10), class = "foo")
env_noclass <- new.env()
env_noclass$x <- 10
env_class <- structure(new.env(), class = "foo")
env_class$x <- 10

microbenchmark(
  list_noclass = list_noclass$x,
  list_class = list_class$x,
  env_noclass = env_noclass$x,
  env_class = env_class$x
)
```

*****

Wrap-up
=======

R6 class objects take less memory and are faster than standard reference class objects. Reference classes do provide additional features, such as type checking of fields, but these aren't, in my opinion, enough to offset the performance penalty and especially the issues with S4 (which reference classes are built on). Another advantage to R6 objects is that they are simpler and easier to understand than R's reference class objects.

Appendix
========

```{r}
sessionInfo()
```
