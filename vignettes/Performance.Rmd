---
title: "Reference class performance tests"
output:
  html_document:
    theme: null
    css: mystyle.css
    toc: yes
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Reference class performance tests}
-->

```{r echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

Reference classes in R are very useful for some situations, but they don't come for free. In this document, I'll explore the costs in memory and speed of standard R reference classes vs. other reference objects which are created in different ways.

I won't cover the other major cost of reference classes, which is the complexity and fickleness of using S4 (since reference classes are built on S4).


```{r}
# Some setup stuff
library(microbenchmark)
library(pryr)           # For object_size function
library(testclasses)    # For Winston's simple reference classes
```

*****

Class definitions
=================

Here are a number of ways of creating reference objects in R, starting with the most complicated (standard R reference class) and ending with the simplest (an environment created by a closure).

## Standard R reference class

```{r}
A_rc <- setRefClass("A_rc", 
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

## Winston's simple reference class

This is a [simpler implementation](https://github.com/wch/testclasses/blob/master/R/ref_class.R) of reference objects, from the [testclasses](https://github.com/wch/testclasses) package.

```{r}
B_wrc <- createRefClass("B_wrc",
  public = list(
    x = NULL,
    initialize = function(x = 1) self$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Objects of this type also have an automatically-created `self` member:

```{r}
print(B_wrc$new())
```

## Winston's simple reference class, without class attribute

By default, a class attribute is added to the objects generated by the simple reference classes. This attribute adds a slight performance penalty because R will use S3 dispatch when using `$` on the object.

It's possible generate objects without the class attribute, by using `class=FALSE`:

```{r}
C_wrc_noclass <- createRefClass("C_wrc_noclass",
  public = list(
    x = NULL,
    initialize = function(x = 1) self$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  ),
  class = FALSE
)
```

## Winston's simple reference class, with public and private members

This is a variant of the previous type of reference class, but this version has public and private members.

```{r}
D_wrc_priv <- createRefClass("D_wrc_priv",
  private = list(x = NULL),
  public = list(
    initialize = function(x = 1) private$x <<- x,
    getx = function() x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Instead of a single `self` object which refers to all items in an object, these objects have `self` (which refers to the public items) and `private`.

```{r}
print(D_wrc_priv$new())
```

## Environment created by a closure, with class attribute

This is simply an environment with a class attached to it.

```{r}
E_closure_class <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  getx <- function() x
  self <- environment()
  class(self) <- "D_closure"
  self
}
```

Even though `x` isn't declared in the function body, it gets captured because it's an argument to the function.

```{r}
# Roundabout way to print the contents of a E object
str(as.list.environment(E_closure_class()))
```

Objects created this way are very similar to those created by `B_wrc`. The main difference is that those created by `B_wrc` contain an `initialize` function:

```{r}
str(as.list.environment(B_wrc$new()))
```


## Environment created by a closure, without class attribute

This is the simplest type of reference object:

```{r}
F_closure_noclass <- function(x = 1) {
  inc <- function(n = 1) x <<- x + n
  getx <- function() x
  environment()
}
```

There are two differences between E and F: objects of type F don't have a class attribute, and they don't have a `self` object.

*****

Tests
=====

For all the timings using `microbenchmark()`, the results are reported in microseconds, and the most useful value is probably the median column.

## Memory footprint

How much memory does a single instance of each object take, and how much memory does each additional object take?

```{r}
# Utility functions for calculating sizes
obj_size <- function(expr, .env = parent.frame()) {
  size_n <- function(n = 1) {
    objs <- lapply(1:n, function(x) eval(expr, .env))
    as.numeric(do.call(object_size, objs))
  }

  data.frame(one = size_n(1), incremental = size_n(2) - size_n(1))
}

obj_sizes <- function(..., .env = parent.frame()) {
  exprs <- as.list(match.call(expand.dots = FALSE)$...)
  names(exprs) <- lapply(1:length(exprs),
    FUN = function(n) {
      name <- names(exprs)[n]
      if (is.null(name) || name == "") paste(deparse(exprs[[n]]), collapse = " ")
      else name
    })

  sizes <- mapply(obj_size, exprs, MoreArgs = list(.env = .env), SIMPLIFY = FALSE)
  do.call(rbind, sizes)
}

```

Sizes of each type of object, in bytes:

```{r}
obj_sizes(
  A_rc$new(),
  B_wrc$new(),
  C_wrc_noclass$new(),
  D_wrc_priv$new(),
  E_closure_class(),
  F_closure_noclass()
)
```


It looks like using a standard reference class takes up a huge amount of memory, but much of that is shared between reference classes. Adding another object from a different reference class doesn't require much more memory -- around 38KB:

```{r}
A_rc2 <- setRefClass("A_rc2",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 2) .self$x <<- x,
    inc = function(n = 2) x <<- x * n
  )
)

# Size of a new A_rc2 object, over and above an A_rc object
as.numeric(object_size(A_rc$new(), A_rc2$new()) - object_size(A_rc$new()))
```

## Object instantiation speed

How much time does it take to create one of these objects?

```{r}
# Garbage collect now so that we (probably) won't do it in the middle of a run
invisible(gc())
speed <- microbenchmark(
  A_rc$new(),
  B_wrc$new(),
  C_wrc_noclass$new(),
  D_wrc_priv$new(),
  E_closure_class(),
  F_closure_noclass(),
  unit = "us"
)
speed
```

Standard R reference classes are much slower to instantiate than the other types of classes, with a median of `r median(speed[speed$expr == "A_rc$new()", "time"]) / 1e6` milliseconds per instantiation.


## Field access speed

How much time does it take to access a field in an object? First we'll make some objects:

```{r}
A <- A_rc$new()
B <- B_wrc$new()
C <- C_wrc_noclass$new()
D <- D_wrc_priv$new()
E <- E_closure_class()
F <- F_closure_noclass()
```

Getting a value:

```{r}
invisible(gc())
microbenchmark(
  A_rc = A$x,
  B_wrc = B$x,
  C_wrc_noclass = C$x,
  D_wrc_priv = D$private$x,
  E_closure_class = E$x,
  F_closure_noclass = F$x,
  unit = "us"
)
```


Setting a value:

```{r}
invisible(gc())
microbenchmark(
  A_rc = A$x <- 4,
  B_wrc = B$x <- 4,
  C_wrc_noclass = C$x <- 4,
  D_wrc_priv = D$private$x <- 4,
  E_closure_class = E$x <- 4,
  F_closure_noclass = F$x <- 4,
  unit = "us"
)
```

The differences between the pairs C, D, and E, F are due to overhead from the class attribute. Because C and E have a class attribute, R will check whether there is a `$` method for its class. All of the objects A, B, D, and E have a class, while C and F do not.

The standard reference class is slowest.


## Method call speed

How much overhead is there when calling a method from one of these objects?

```{r}
invisible(gc())
microbenchmark(
  A_rc = A$getx(),
  B_wrc = B$getx(),
  C_wrc_noclass = C$getx(),
  D_wrc_priv = D$getx(),
  E_closure_class = E$getx(),
  F_closure_noclass = F$getx(),
  unit = "us"
)
```

As expected, method call speed is very close to the field access speed -- in this case there's just the small additional overhead of calling a function.

Standard reference classes are the slowest by a large margin.

The difference between the pairs B, C, and E, F is probably due to S3 method lookup for the `$` function -- there could be a `$.myclass` method which would be called for `myclass` objects.


## Overhead from using `self`

With standard reference class objects, you can modify fields using the `<<-` operator, or by using the `self` object. For example, compare the `inc()` methods of these two classes:

```{r}
rc_self <- setRefClass("rc_self",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <- x,
    inc = function(n = 1) .self$x <- x + n
  )
)

rc_no_self <- setRefClass("rc_no_self",
  fields = list(x = "numeric"),
  methods = list(
    initialize = function(x = 1) .self$x <- x,
    inc = function(n = 1) x <<- x + n
  )
)
```

Winston's reference classes are similar, except they use `self` instead of `.self`:

```{r}
wrc_self <- createRefClass("wrc_self",
  public = list(
    x = 1,
    inc = function(n = 1) self$x <- x + n
  )
)

wrc_no_self <- createRefClass("wrc_no_self",
  public = list(
    x = 1,
    inc = function(n = 1) x <<- x + n
  )
)
```


```{r}
rc_self_obj <- rc_self$new()
rc_no_self_obj <- rc_no_self$new()
wrc_self_obj <- wrc_self$new()
wrc_no_self_obj <- wrc_no_self$new()

invisible(gc())
microbenchmark(
  rc_self = rc_self_obj$inc(),
  rc_no_self = rc_no_self_obj$inc(),
  wrc_self = wrc_self_obj$inc(),
  wrc_no_self = wrc_no_self_obj$inc(),
  unit = "us"
)
```

Using `.self` or `self` adds some overhead, which makes sense when you consider how R searches for objects.

When the method accesses `x` without using `.self`, R first searches in the execution environment but doesn't find `x` there, so it then searches in the parent environment, finds `x` there, and assigns the value.

When using `.self`, R searches for `.self` in the function's execution environment but doesn't find it there, so it looks in the parent environment (which also happens to be the object environment, as well as the environment that `.self` points to) and does find it there. Then it looks in the `.self` environment for `x`, and assigns the value.

Additionally, there is some overhead when the environment has a class attribute.

```{r}
wrc_self_obj <- wrc_self$new()
wrc_no_self_obj <- wrc_no_self$new()

wrc_self_noclass_obj <- wrc_self$new()
class(wrc_self_noclass_obj) <- NULL
wrc_no_self_noclass_obj <- wrc_no_self$new()
class(wrc_no_self_noclass_obj) <- NULL

invisible(gc())
microbenchmark(
  wrc_self = wrc_self_obj$inc(),
  wrc_no_self = wrc_no_self_obj$inc(),
  wrc_self_noclass = wrc_self_noclass_obj$inc(),
  wrc_no_self_noclass = wrc_no_self_noclass_obj$inc(),
  unit = "us"
)
```


## Lists vs. environments, and S3 object access overhead

This compares member access time with lists vs. environments, and when the list/environment has a class attribute vs. not having a class. If the class has a class attribute, R will use method lookup for `$`, which adds overhead.

```{r}
list_noclass <- list(x = 10)
list_class <- structure(list(x = 10), class = "foo")
env_noclass <- new.env()
env_noclass$x <- 10
env_class <- structure(new.env(), class = "foo")
env_class$x <- 10

invisible(gc())
microbenchmark(
  list_noclass = list_noclass$x,
  list_class = list_class$x,
  env_noclass = env_noclass$x,
  env_class = env_class$x,
  unit = "us"
)
```

*****

Wrap-up
=======

Standard reference class objects take more memory and are slower than other, simpler types of reference objects. They do provide additional features, such as type checking of fields and class inheritance, but these aren't, in my opinion, enough to offset the performance penalty and especially the pain of dealing with S4 (which reference classes are built on). Type checking of fields is only a minor benefit, and it would be simple to add inheritance to Winston's reference class implementation. It would also be simple to implement private and public members, though there would be a small performance penalty.

Another drawback to standard R reference class objects is it's not entirely clear how they work, as many advanced R developers can attest. The other types of reference objects used here are simple and can be understood completely, as long as one understands how environments work.

Appendix
========

```{r}
sessionInfo()
```
